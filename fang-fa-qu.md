# 方法区

## 栈、堆、方法区的交互关系

### 从线程共享与否的角度看

![](.gitbook/assets/screen-shot-2021-08-13-at-11.34.22-pm.png)

### 交互关系

![](.gitbook/assets/screen-shot-2021-08-13-at-11.35.07-pm.png)

## 方法区的理解

* 方法区可以看作是一块独立于Java堆的内存空间。**类\(class\)放在方法区，new的对象放在堆空间**

![](.gitbook/assets/screen-shot-2021-08-14-at-11.28.50-pm.png)

* 方法区与堆一样，是各个线程共享的内存区域。一个类只被加载一次 - 如果同时多个线程要加载一个类，只能其中一个加载
* 方法区在JVM启动时被创建，并且和堆空间一样，它的实际物理内存可以是不连续的
* 方法区的大小可以选择固定大小，也可以选择可扩展大小，和堆空间一样
* 方法区的大小决定了系统可以保存多少个类。如果系统定义了太多的类（例如：加载大量第三方jar包；Tomcat部署的工程过多；大量动态的生成反射类），导致方法区溢出，JVM会抛出内存溢出错误\(OOM\) java.lang.OutOfMemoryError: **PermGen space** \(Java7及以前\) 或者 java.lang.OutOfMemoryError: **Metaspace** \(Java8以后\)
* 关闭JVM就会释放方法区内存

## 设置方法区大小与OOM

## 方法区的内部结构


方法区用于存储**已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等**

![](.gitbook/assets/screen-shot-2021-08-16-at-5.12.18-pm.png)

![](.gitbook/assets/screen-shot-2021-08-16-at-5.12.42-pm.png)

### 类型信息

对每个加载的类型\(类、接口、枚举、注解\)，JVM必须在方法区中存储以下类型信息

* 类型的完整有效名称\(全名 = 包名.类名\)
* 类型直接父类的完整有效名称\(对于interface或java.lang.Object，都没有父类\)
* 类型的修饰符\(public, abstract, final\)
* 类型直接接口的一个有序列表

### 域信息（成员变量、属性）

域的相关信息包括：域名称、域类型、域修饰符\(public, private, protected, static, final, volatile, transient\)

### 方法信息

方法信息包括

* 方法名称
* 方法的返回类型\(或void\)
* 方法参数的数量和类型\(按顺序\)
* 方法的修饰符\(public, private, protected, static, final, synchronized, native, abstract\)
* 方法的字节码\(bytecodes\)、操作数栈大小、局部变量表及大小
* 异常表 - 每个异常处理的开始位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引
* 参考Chapter09 - MethodAreaInnerStruc

### non-final的类变量

* 静态变量和类关联在一起，随着类的加载而加载，它们成为类数据在逻辑上的一部分
* 类变量被类的所有实例共享，即使没有类实例（实例为null），也可以访问
* 参考Chapter09 - NonFinalVariableDemo

### 全局常量\(static final\)

被声明为final的类变量的处理方式则不同，每个全局常量在编译时就会被分配了

### 常量池

* **常量池在字节码文件，运行时常量池在方法区**
* 字节码文件\(Class Files\)中的常量池经过类加载子系统加载到运行时数据区中的方法区后，对应的结构叫做运行时常量池
* 一个有效的字节码文件中包含类的版本信息、字段、方法以及接口等描述信息，还包含常量池表\(Constant Pool Table\)，包括各种字面量\(e.g. String s = "hello"\)和对类型、域和方法的符号引用
* 一个Java源文件在编译后产生一个字节码文件。而字节码需要数据支持，通常这种数据会很大以至于不能直接存在字节码中，需要换成另一种方式，即存到常量池。这个字节码文件包含了指向常量池的引用。在动态链接的时候，会用到运行时常量池。
* 常量池中存储的数据类型
  * 数量值
  * 字符串值
  * 类引用
  * 字段引用
  * 方法引用
* **常量池可以看作是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等类型**

### **运行时常量池**

* 运行时常量池是方法区的一部分
* 常量池表是字节码文件的一部分，**用于存放编译期生成的各种字面量与符号引用**，这部分内容**在类加载后存放到方法区的运行时常量池中**
* **JVM为每个已加载的类型（类或接口）都维护一个常量池。**池中的数据项像数组项一样，通过索引进行访问
* 运行时常量池中包含多种不同的常量，包括编译期就已明确数值的字面量，也包括到运行期解析后才能获得的方法或者字段引用。此时不再是常量池中的符号地址，而是换为真实地址 - **运行时常量池相对于常量池的一个重要不同是：具备动态性**
* 运行时常量池类似于传统编程语言中的符号表，但它所包含的数据比符号表更丰富一些
* 当构造运行时常量池所需的内存空间超过了方法区所能提供的最大值，则JVM会抛出OOM异常


## 方法区使用举例

## 方法区的演进细节

## 方法区的垃圾回收

## 总结

