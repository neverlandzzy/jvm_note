# 虚拟机栈\(JVM栈\)

## 虚拟机栈概述

由于跨平台性的设计，Java的指令都是根据栈来设计的。不同平台CPU架构不同，因此不能设计为基于寄存器的指令。相比于基于寄存器的指令，**优点是跨平台，指令集小，编译器容易实现。缺点是性能下降，实现同样的功能需要更多的指令**。

**栈是运行时的单位，堆是存储的单位。**栈解决程序的运行问题，即程序如何执行；堆解决数据存储问题，即数据怎么存、存在哪。

每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧\(Stacjk Frame\)，**一个栈帧对应一个Java方法**。JVM栈是线程私有的，生命周期和线程一致。主管Java程序的运行，它保存方法的局部变量、部分结果，并参与方法的调用和返回。

* 栈中保存的局部变量包括**8种基本数据类型**和**对象的引用地址**
* 对象本身保存在堆空间
* 变量可以分为基本数据变量和引用类型变量（类、数组、接口）

**栈的优点**

* 栈是一种快速有效的分配存储方式，访问速度仅次于程序计数器
* 栈的操作只有进栈和出栈 - 每个方法执行伴随着进栈，方法执行结束后出栈
* 栈不存在垃圾回收\(GC\)的问题，但可能存在栈溢出\(OOM\)（程序计数器既不存在GC也不存在OOM）

**【面试题】开发中遇到的JVM相关异常有哪些**

* JVM规范允许虚拟机栈的大小是动态的或固定不变的
  * 若采用固定大小，那么每一个线程的虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的栈超过虚拟机栈允许的最大容量，JVM会抛出**StackOverflowError**
  * 若可以动态扩展，但在尝试扩展时无法申请到足够的内存或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，JVM会抛出**OutOfMemoryError**

**设置栈内存大小 -Xss** - 参考 Chapter05 - StackSize 和[Java Doc](https://docs.oracle.com/en/java/javase/11/tools/java.html#GUID-3B1CE181-CD30-4178-9602-230B800D4FAE)

## 栈的存储单位

每个线程都有自己的栈，栈中的数据都是以栈帧\(Stack Frame\)的格式存在。线程上正在执行的每个方法都各自对应一个栈帧，即**方法和栈帧一一对应**。

**栈的运行原理**

![](.gitbook/assets/screen-shot-2021-07-18-at-6.13.13-pm.png)

* JVM栈的操作只有**压栈**和**出栈**，遵循**先入后出**原则
* 在一条活动线程中，在一个时间点上，只有一个活动的栈帧，即只有当前正在执行的方法的栈帧（在栈顶）是有效的。这个栈帧被称为**当前栈帧\(Current Frame\)**，与其对应的方法叫做**当前方法\(Current Method\)**，定义这个方法的类叫做**当前类\(Current Class\)**
* 执行引擎运行的所有字节码指令只针对当前栈帧进行操作
* 如果在当前方法中调用的其它方法，对应的新的栈帧会被创建出来，放在栈顶，成为新的当前栈帧
* 不同线程中所包含的栈帧是不允许存在互相引用的，即不可能在一个栈帧中引用另外一个线程的栈帧
* 如果当前方法调用了其它方法，方法返回时，当前栈帧会传回此方法的执行结果给前一个栈帧，然后JVM会丢弃当前栈帧，使前一个栈帧重新成为当前栈帧
* Java方法有两种返回函数的方式，两种方式都会导致栈帧被弹出
  * 正常的函数返回，使用return指令
  * 抛出异常

**栈帧的内部结构**

![](.gitbook/assets/screen-shot-2021-07-19-at-8.49.06-pm.jpeg)

* 局部变量表\(Local Variables\)
* 操作数栈\(Operand Stack，或表达式栈\)
* 动态链接\(Dynamic Linking，或指向运行时常量池的方法引用\)
* 方法返回地址\(Return Address，或方法正常退出或者异常退出的定义\)
* 一些附加信息

## 局部变量表\(Local Variables\)

* 局部变量表也被称为**局部变量数组**或**本地变量表**
* **定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量**，这些数据类型包括各类基本数据类型、对象引用以及returnAddress
* 局部变量表是建立在线程的栈上，是线程私有数据，**不存在数据安全问题**
* **局部变量表所需的容量大小是在编译期确定下来的**，并保存在方法的Code属性的maximum local variables数据项中，在方法运行期间是不会改变的
* 方法嵌套调用的次数由栈的大小决定。一般来说，栈越大，方法嵌套调用次数越多。
* **局部变量表中的变量只在当前方法调用中有效。**在方法执行时，JVM通过使用局部变量表完成参数值到参数变量列表的传递过程。当方法调用结束后，**随着方法栈帧的销毁，局部变量表也会随之销毁。**
* 局部变量表中的变量也是重要的垃圾回收根节点，**只要被局部变量表中直接或间接引用的对象都不会被回收**

**关于变量槽Slot的理解**

![](.gitbook/assets/screen-shot-2021-07-19-at-10.38.02-pm.png)

* 参数值的存放总是在局部变量数据的index0开始，到数组长度-1的索引结束
* 局部变量表最基本的存储单元是变量槽\(Slot\)
* 局部变量表中存放编译期可知的各种基本数据类型（8种）、引用类型、returnAddress类型的变量
* 在局部变量表中，32位以内的类型只占用一个slot（包括returnAddress类型），64位的类型（long和double）占用两个slot
  * byte, short, char， boolean在存储前被转换为int，float占一个slot
  * long和double占两个slot
* JVM为局部变量表中的每一个slot分配一个访问索引，通过索引即可访问到局部变量表中指定的局部变量值
* 当一个实例方法被调用时，它的方法参数和方法内部定义的局部变量**将会按照顺序被复制**到局部变量表中的每一个slot上
* 如果需要访问局部变量表中的一个64bit的局部变量值时，只需要使用前一个索引
* 如果当前帧是由**构造方法**或者**实例方法**创建的，那么**该对象引用this将会存放在index为0的slot**，其余的参数按照参数表顺序继续排列
* **栈帧中局部变量表中的槽位是可以重复利用的。**如果一个局部变量过了其作用域，那么在其作用域之后申明的新的局部变量就有可能会复用过期的局部变量的槽位，从而达到节省资源的目的。

**静态变量与局部变量对比**

* 变量的分类
  * 按数据类型分：基本数据类型，引用数据类型
  * 按在类中声明的位置分：成员变量（类变量\(static\)，实例变量\(无static\)），局部变量
* 参数表分配完毕后，再根据方法体内定义的变量顺序和作用域分配
* 类变量表有两次初始化，第一次在linking的准备阶段，执行系统初始化，对类变量设置零值，另一次在初始化阶段，赋予在代码中定义的初始值
* 和类变量初始化不同，局部变量表不存在系统初始化过程，一旦定义了局部变量则必须认为的初始化，否则无法使用

## 操作数栈\(Operand Stack\)

* 操作数栈在方法执行过程中，根据字节码指令，往栈中写入数据或提取数据、即入栈或出栈
* 某些字节码指令将值压入操作数栈，其余的字节码指令将操作数取出栈，使用它们后再把结果压入栈，例如：复制、交换、求和等操作
* 操作数栈**主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间**
* 操作数栈就是JVM执行引擎的一个工作区，**当一个方法刚开始执行的时候，一个新的栈帧也会随之被创建出来，这个方法的操作数栈是空的**
* 每一个操作数栈都会拥有一个明确的栈深度用于存储数值，其所需的最大深度在编译期就定义好了，保存在方法的Code的max\_stack属性中
* 栈中的任何一个元素都可以是任意的Java数据类型
  * 32bit的类型占用一个栈单位深度
  * 64bit的类型占用两个栈单位深度
* 操作数栈并非采用访问索引的方式来进行数据访问的，**而是只能通过标准的入栈和出栈操作完成一次数据访问**
* 如果被调用的方法带有返回值，其返回值会被压入当前栈帧的操作数中，并更新PC寄存器中下一条需要执行的字节码指令
* 操作数中元素的数据类型必须与字节码指令的序列严格匹配，这由编译器在编译期间进行验证，同时在类加载过程中的类检验阶段的数据流分析阶段再次验证
* Java虚拟机的解释引擎是基于栈的执行引擎，其中的栈指的就是操作数栈
* 实例参考视频P53，代码Chapter05 - OperandStack

## 栈顶缓存技术\(Top-of-Stack Caching\)

基于栈式架构的虚拟机所使用的零地址指令更加紧凑，但完成一项操作时必然需要更多的入栈和出栈指令，意味着需要更多的指令分派次数和内存读写次数。由于操作数是存储在内存中的，频繁地执行内存读写必然影响执行速度。为了解决这个问题，**HotSpot JVM采用了栈顶缓存技术，将栈顶元素全部缓存在物理CPU的寄存器中，以降低内存读写次数，提升执行引擎的执行效率**





