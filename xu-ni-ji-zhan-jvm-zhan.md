# 虚拟机栈\(JVM栈\)

## 虚拟机栈概述

由于跨平台性的设计，Java的指令都是根据栈来设计的。不同平台CPU架构不同，因此不能设计为基于寄存器的指令。相比于基于寄存器的指令，**优点是跨平台，指令集小，编译器容易实现。缺点是性能下降，实现同样的功能需要更多的指令**。

**栈是运行时的单位，堆是存储的单位。**栈解决程序的运行问题，即程序如何执行；堆解决数据存储问题，即数据怎么存、存在哪。

每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧\(Stacjk Frame\)，**一个栈帧对应一个Java方法**。JVM栈是线程私有的，生命周期和线程一致。主管Java程序的运行，它保存方法的局部变量、部分结果，并参与方法的调用和返回。

* 栈中保存的局部变量包括**8种基本数据类型**和**对象的引用地址**
* 对象本身保存在堆空间
* 变量可以分为基本数据变量和引用类型变量（类、数组、接口）

**栈的优点**

* 栈是一种快速有效的分配存储方式，访问速度仅次于程序计数器
* 栈的操作只有进栈和出栈 - 每个方法执行伴随着进栈，方法执行结束后出栈
* 栈不存在垃圾回收\(GC\)的问题，但可能存在栈溢出\(OOM\)（程序计数器既不存在GC也不存在OOM）

**【面试题】开发中遇到的JVM相关异常有哪些**

* JVM规范允许虚拟机栈的大小是动态的或固定不变的
  * 若采用固定大小，那么每一个线程的虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的栈超过虚拟机栈允许的最大容量，JVM会抛出**StackOverflowError**
  * 若可以动态扩展，但在尝试扩展时无法申请到足够的内存或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，JVM会抛出**OutOfMemoryError**

**设置栈内存大小 -Xss** - 参考 Chapter05 - StackSize 和[Java Doc](https://docs.oracle.com/en/java/javase/11/tools/java.html#GUID-3B1CE181-CD30-4178-9602-230B800D4FAE)

## 栈的存储单位

每个线程都有自己的栈，栈中的数据都是以栈帧\(Stack Frame\)的格式存在。线程上正在执行的每个方法都各自对应一个栈帧，即**方法和栈帧一一对应**。

**栈的运行原理**

![](.gitbook/assets/screen-shot-2021-07-18-at-6.13.13-pm.png)

* JVM栈的操作只有**压栈**和**出栈**，遵循**先入后出**原则
* 在一条活动线程中，在一个时间点上，只有一个活动的栈帧，即只有当前正在执行的方法的栈帧（在栈顶）是有效的。这个栈帧被称为**当前栈帧\(Current Frame\)**，与其对应的方法叫做**当前方法\(Current Method\)**，定义这个方法的类叫做**当前类\(Current Class\)**
* 执行引擎运行的所有字节码指令只针对当前栈帧进行操作
* 如果在当前方法中调用的其它方法，对应的新的栈帧会被创建出来，放在栈顶，成为新的当前栈帧
* 不同线程中所包含的栈帧是不允许存在互相引用的，即不可能在一个栈帧中引用另外一个线程的栈帧
* 如果当前方法调用了其它方法，方法返回时，当前栈帧会传回此方法的执行结果给前一个栈帧，然后JVM会丢弃当前栈帧，使前一个栈帧重新成为当前栈帧
* Java方法有两种返回函数的方式，两种方式都会导致栈帧被弹出
  * 正常的函数返回，使用return指令
  * 抛出异常

