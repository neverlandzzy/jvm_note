# 垃圾回收相关算法

## 标记阶段：引用计数算法

堆空间存放着几乎所有的Java对象实例，在GC执行垃圾回收之前，首先需要区分出内存中哪些是存活对象，哪些是已经死亡的对象。只有被标记为已经死亡的对象，GC才会在执行垃圾回收时，释放其所占用的内存空间，因此这个过程称为**垃圾标记阶段**

当一个对象已经不再被任何的存活对象继续引用时，就可以认为这个对象已经死亡。判断对象存活一般有两种方式：**引用计数算法**和**可达性分析算法**。

引用计数法\(Reference Counter\) 对每个对象保存一个整型的引用计数器属性，用于记录对象被引用的情况。对于一个对象A，只要有任何一个对象引用了A，则A的引用计数器加1；当引用失效时，引用计数器减1。只要A的引用计数器为0，则表示A不可能再被使用，可以进行回收。

**优点：**

* 实现简单，垃圾对象便于辨识；
* 判定效率高，回收没有延迟性

**缺点：**

* 需要单独的字段存储计数器，这样增加了存储**空间的开销**
* 每次赋值都需要更新计数器，伴随着加法和减法操作，增加了**时间的开销**
* 一个严重的问题：无法处理**循环引用**的情况 - **因而Java的GC中没有使用这类算法**
* Python中使用了这个算法，通过手动解除和使用弱引用\(weakref\)来解决循环引用的问题

![&#x5FAA;&#x73AF;&#x5F15;&#x7528;](.gitbook/assets/screen-shot-2021-09-29-at-6.02.31-pm.png)

## 标记阶段：可达性分析算法（根搜索算法、追踪性垃圾收集）

相对于引用计数算法，可达性分析算法不仅同样具备实现简单和执行高效等特点，还可以有效解决循环引用的问题，防止内存泄漏的发生。Java, C\#使用这个算法。

**基本思路**

* **根对象集合\(GC Roots\)**是指一组必须活跃的引用
* 可达性分析算法是以**根对象集合**为起始点，按照从上至下的方式搜索被根对象集合所连接的目标对象是否可达
* 使用可达性分析算法后，内存中的存活对象都会被根对象集合直接或间接连接着，搜索所走过的路径称为**引用链\(Reference Chain\)**
* 如果目标对象没有任何引用链相连，则是不可达的，就意味着该对象已经死亡，可以标记为垃圾对象
* 在可达性分析算法中，只有能被根对象集合直接或间接连接的对象才是存活的

![](.gitbook/assets/screen-shot-2021-09-29-at-9.44.10-pm.png)

**Java中，GC Roots包括以下几类元素（高频面试题）**

* 虚拟机栈中引用的对象，如各个线程被调用的方法中使用的参数、局部变量等
* 本地方法栈内JNI\(Java Native Interface, Java本地接口\)引用的对象
* 方法区中类静态属性引用的对象，如引用类型静态变量
* 方法区中常量引用的对象，如字符串常量池中的引用
* 所有被同步锁synchronized持有的对象
* JVM内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象，系统类加载器
* 反映JVM内部情况的JMXBean, JVMTI中注册的回调、本地缓存等
* 特殊情况 - 除了上述固定的GC Roots外，根据用户所选用的垃圾收集器以及当前回收的内存区域不同，还可以有其它对象临时性地加入，共同构成完整的GC Roots集合，比如**分代收集**和**局部回收**

**小结：如果一个指针，它保存了堆内存里面的对象，但自己又不存放在堆内存里面，则它是一个Root**

![](.gitbook/assets/screen-shot-2021-09-29-at-9.58.20-pm.png)

如果使用可达性分析算法来判断内存是否可回收，那么分析工作必须在一个能保障一致性的快照中进行，这点不满足的话，分析结果的准确性就无法保。这也是GC进行时必须"Stop The Wolrd"的一个重要原因，在枚举根节点时必须要停顿

## 对象的finalization机制

Java提供了对象终止机制来允许开发人员提供对象被销毁前的自定义处理逻辑

当GC发现没有引用指向一个对象，即垃圾回收之前，总会先调用这个对象的**finalize\(\)**方法

finalize\(\)方法允许在子类中被重写，用于在对象被回收时进行资源释放。通常在这个方法中进行一些资源释放和清理工作，比如关闭文件、套接字和数据库连接等。

**永远不要主动调用某个对象的finalize\(\)方法，应该交给GC调用**，因为

* finalize\(\)方法可能会导致对象复活 - 参考Chapter15 - ObjectRelive
* finalize\(\)方法的执行时间是没有保障的，它完全由GC线程决定，极端情况下，若不发生GC，则finalize\(\)方法将没有执行机会
* 一个糟糕的finalize\(\)方法会严重影响GC性能

由于finalize\(\)方法的存在，JVM中的对象一般处于三种可能的状态。如果从所有根节点都无法访问到某个对象，说明对象已经不再使用了，这样的对象需要被回收。但一个无法触及的对象可能在某一条件下在finalize\(\)中被复活，因此不能对这样的对象进行回收。

* **可触及的** - 从根节点可以访问到这个对象
* **可复活的** - 对象的所有引用都被释放，但对象可能在finalize\(\)中复活
* **不可触及的** - 对象的finalize\(\)被调用，并且没有复活，就会进入不可触及状态。**不可触及的对象不可能被复活，因为finalize\(\)只能被调用一次。这样的对象可以被回收。**

**只有对象在不可触及时才可以被回收**

**判断一个对象objA是否可回收至少要经历两次标记过程：**

* 如果objA到GC Roots没有引用链，则进行第一次标记
* 进行筛选，判断此对象是否有必要执行finalize\(\)方法
  * 如果objA没有重写finalize\(\)方法，或者finalize\(\)方法已经被JVM调用过，则JVM视为没有必要执行，objA被判定为不可触及的对象
  * 如果objA重写了finalize\(\)方法，且还未执行过，那么objA会被插入到F-Queue队列中，由一个JVM自动创建的、低优先级的**Finalizer线程**触发其finalize\(\)方法执行
  * finalize\(\)方法是对象逃脱死亡的最后机会。如果objA在finalize\(\)方法中与引用链上的任何一个对象建立了联系，那么在第二次标记时，objA会被移出到“即将回收”集合。之后，对象会再次出现没有引用存在的情况，这时，finalize\(\)方法不会再次被调用，对象会直接变成不可触及的状态，即**finalize\(\)方法只能被调用一次**

## MAT与JProfiler的GC Roots溯源

MAT下载地址：[https://www.eclipse.org/mat/](https://www.eclipse.org/mat/)

参考chapter15 - GCRootsTest

获取heap dump文件

* 方式1 - 命令行使用jmap `jmap -dump:format=b,live,file=GCRootsTest.bin 12794`

```text
neverland@neverlands-mbp ~ % jps                                                
12768 Main
12472 
12793 Launcher
12794 GCRootsTest
12812 Jps
neverland@neverlands-mbp ~ % jmap -dump:format=b,live,file=GCRootsTest.bin 12794
Dumping heap to /Users/neverland/GCRootsTest.bin ...
Heap dump file created
```

* 方式2 - 使用JVisualVM导出: 选中进程 -&gt; Monitor -&gt; heap dump -&gt; 保存到本地

## 清除阶段：标记-清除算法

## 清除阶段：复制算法

## 清除阶段：标记-压缩算法

## 小结

## 分代收集算法

## 增量收集算法、分区算法





