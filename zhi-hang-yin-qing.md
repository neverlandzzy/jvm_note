# 执行引擎

## 执行引擎概述

“虚拟机”是相对于“物理机”的概念，二者都有代码执行能力。区别在于，物理机的执行引擎是直接建立在处理器、缓存、指令集和操作系统层面上的，而**虚拟机的执行引擎是由软件自行实现的**，因此可以不受物理条件制约地定制指令集与执行引擎的结构体系，**能够执行那些不被硬件直接支持的指令集格式。**

![](.gitbook/assets/screen-shot-2021-09-19-at-4.45.13-pm.png)

JVM的主要任务是负责装载字节码到其内部，但字节码并不能直接运行在操作系统之上，因为字节码指令并非等价于本地机器指令，它内部包含的仅仅是一些能够被JVM所识别的字节码指令、符号表以及其它辅助信息。因此如果要让一个Java程序运行起来，**执行引擎的任务就是将字节码指令解释/编译为对应平台上的本地机器指令。**

![](.gitbook/assets/screen-shot-2021-09-19-at-4.55.10-pm.png)

**执行引擎的工作过程**

* 执行引擎在执行过程中究竟需要执行什么样的字节码指令完全依赖于PC寄存器
* 每当执行完一项指令操作后，PC寄存器就会更新下一条需要被执行的指令地址
* 方法在执行的过程中，执行引擎有可能会通过存储在局部变量表中的对象引用准确定位到存储在Java堆中的对象实例信息，以及通过对象头中的元数据指针定位到目标对象的类型信息

所有JVM的执行引擎输入、输出都是一致的：**输入的是字节码的二进制流，处理过程是字节码解析执行的等效过程，输出的是执行结果。**

## Java代码编译和执行过程

大部分的程序代码转换成物理机的目标代码或虚拟机能执行的指令集之前，都要经过图中这些步骤

* **橙色 -** 从程序源码到抽象语法树，是由Java源代码生成字节码指令的过程，经过javac编译**（称为前端编译）**，这部分与JVM无关
* **绿色** - 逐行解释执行
* **蓝色** - 传统的编译过程（**称为后端编译）**，最终生成机器代码

Java是半解释半编译语言

* **解释器** - 当JVM启动时，会根据预定义的规范，对字节码采用逐行解释的方式执行，将每条字节码文件中的内容翻译为对应平台的本地机器指令执行
* **JIT\(Just-In-Time\)编译器** - JVM将源代码直接编译成和本地机器相关的机器指令

![](.gitbook/assets/screen-shot-2021-09-19-at-9.40.58-pm.png)

Java字节码的执行是由JVM执行引擎来完成

![](.gitbook/assets/screen-shot-2021-09-19-at-9.50.41-pm.png)

## 机器码、指令、汇编语言

![](.gitbook/assets/screen-shot-2021-09-19-at-9.59.09-pm.png)

![](.gitbook/assets/screen-shot-2021-09-19-at-10.08.20-pm.png)

## 解释器

## JIT编译器

### 解释器和编译器各自的优点

* 当程序启动后，解释器可以马上发挥作用，省去编译时间，立即执行，响应速度快
* 编译器把代码编译成本地机器指令需要一定的执行时间，但编译后执行效率更高
* 对于服务端应用，启动时间并非是关注的重点（所以JRockit 虚拟机中就不包含解释器），但对于看中启动时间的应用，就需要解释器与即时编译器并存的架构
* 解释执行可以在编译器进行激进优化不成立时，作为编译器的后备方案

### HotSpot JVM的执行方式

当JVM启动时，解释器可以首先发挥作用，而不必等待即时编译器全部编译完成再执行。随着程序运行，根据热点探测功能，即时编译器将有价值的字节码编译为本地机器指令，以换取更高的执行效率。

